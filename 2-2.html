<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>2-2 予算種別・歳出予算項目 グラフ</title>
    <style>
      :root {
        --bg: #f6f7f9;
        --card: #ffffff;
        --ink: #1f2937;
        --muted: #6b7280;
        --accent: #0ea5a4;
        --bar: #0f766e;
        --bg2: #f0f4f8;
      }
      * { box-sizing: border-box; }
      body {
        margin: 0;
        font-family: "Hiragino Sans", "Noto Sans JP", "Yu Gothic", "Meiryo", sans-serif;
        background: var(--bg);
        color: var(--ink);
      }
      header {
        padding: 20px 24px;
        border-bottom: 1px solid #e5e7eb;
        background: #ffffff;
      }
      h1 { margin: 0 0 6px; font-size: 20px; }
      .sub { color: var(--muted); font-size: 12px; }
      main { padding: 20px 24px 40px; }
      .grid {
        display: grid;
        gap: 16px;
        grid-template-columns: 1fr;
      }
      .card {
        background: var(--card);
        border: 1px solid #e5e7eb;
        border-radius: 12px;
        padding: 16px;
      }
      .controls {
        display: grid;
        gap: 12px;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        align-items: end;
      }
      label { font-size: 12px; color: var(--muted); display: block; margin-bottom: 6px; }
      select, input {
        width: 100%;
        padding: 8px 10px;
        border: 1px solid #d1d5db;
        border-radius: 8px;
        background: #fff;
      }
      .bars { display: grid; gap: 10px; }
      .bar-row { display: grid; grid-template-columns: 200px 1fr 120px; gap: 12px; align-items: center; }
      .bar-label { font-size: 12px; color: var(--ink); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
      .bar-track {
        height: 12px;
        background: #e5e7eb;
        border-radius: 999px;
        position: relative;
      }
      .bar-fill {
        position: absolute;
        left: 0; top: 0; bottom: 0;
        background: var(--bar);
        border-radius: 999px;
      }
      .bar-value { font-size: 12px; text-align: right; color: var(--ink); }
      .stacked {
        display: grid;
        gap: 12px;
      }
      .stack-chart {
        height: 420px;
        display: grid;
        grid-template-columns: 48px 1fr;
        gap: 8px;
        align-items: stretch;
      }
      .y-axis {
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        font-size: 11px;
        color: var(--muted);
        padding: 6px 0;
        text-align: right;
      }
      .plot {
        position: relative;
        height: 100%;
        background: var(--bg2);
        border-radius: 12px;
        padding: 12px;
      }
      .gridline {
        position: absolute;
        left: 12px;
        right: 12px;
        height: 1px;
        background: #e5e7eb;
      }
      .bars-grid {
        position: relative;
        height: 100%;
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(54px, 1fr));
        align-items: end;
        gap: 16px;
      }
      .stack-col {
        display: grid;
        grid-template-rows: 1fr auto;
        align-items: end;
        justify-items: center;
        height: 100%;
      }
      .bar-holder {
        width: 100%;
        height: 100%;
        display: flex;
        align-items: flex-end;
        justify-content: center;
      }
      .stack-bar {
        width: 100%;
        max-width: 54px;
        display: flex;
        flex-direction: column;
        justify-content: flex-end;
        border-radius: 8px;
        overflow: hidden;
        background: #e5e7eb;
        outline: 1px solid #e5e7eb;
      }
      .stack-seg {
        width: 100%;
        transition: filter 120ms ease;
      }
      .stack-seg:hover { filter: brightness(0.92); }
      .stack-label {
        font-size: 11px;
        color: var(--muted);
      }
      .tooltip {
        position: absolute;
        pointer-events: none;
        background: #111827;
        color: #fff;
        font-size: 12px;
        padding: 6px 8px;
        border-radius: 6px;
        opacity: 0;
        transform: translate(-50%, -8px);
        transition: opacity 120ms ease;
        white-space: nowrap;
        z-index: 10;
      }
      .legend {
        display: grid;
        gap: 6px 12px;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        font-size: 12px;
        color: var(--muted);
      }
      .legend-item { display: flex; align-items: center; gap: 8px; }
      .legend-swatch { width: 12px; height: 12px; border-radius: 3px; }
      .legend-check { width: 14px; height: 14px; }
      table { width: 100%; border-collapse: collapse; font-size: 12px; }
      th, td { padding: 8px; border-bottom: 1px solid #e5e7eb; text-align: left; }
      th { color: var(--muted); font-weight: 600; }
      .note { font-size: 12px; color: var(--muted); }
      @media (max-width: 720px) {
        .bar-row { grid-template-columns: 1fr; align-items: start; }
        .bar-value { text-align: left; }
      }
    </style>
  </head>
  <body>
    <header>
      <h1>2-2 予算種別・歳出予算項目 グラフ</h1>
      <div class="sub">データ: `2-2_RS_2025_予算・執行_予算種別・歳出予算項目.csv`（金額単位: 円）</div>
    </header>
    <main class="grid">
      <section class="card">
        <div class="controls">
          <div>
            <label for="fileInput">CSVファイル</label>
            <input id="fileInput" type="file" accept=".csv" />
          </div>
          <div>
            <label for="presetSelect">分類プリセット</label>
            <select id="presetSelect"></select>
          </div>
          <div>
            <label for="ministrySelect">府省庁</label>
            <select id="ministrySelect"></select>
          </div>
          <div>
            <label for="accountSelect">会計区分</label>
            <select id="accountSelect">
              <option value="一般会計">一般会計</option>
              <option value="特別会計">特別会計</option>
              <option value="">（両方）</option>
            </select>
          </div>
          <div>
            <label for="aiMap">AI分類JSON（任意）</label>
            <input id="aiMap" type="file" accept=".json" />
          </div>
        </div>
        <p class="note">注意: 本ページは集計ロジック検討用の簡易グラフです。ファイル直開きの場合はCSVの読み込みに失敗するため、上のファイル選択から読み込んでください。</p>
        <p class="note">AI分類JSONの形式（例）: {"事業名A":"教育","事業名B":"福祉"} / 未指定は簡易ルール分類。</p>
      </section>

      <section class="card">
        <h2 style="margin:0 0 12px;font-size:16px;">年度別の大項目（事業名AI分類）積み上げ棒</h2>
        <div id="legend" class="legend"></div>
        <div id="stacked" class="stacked" style="margin-top:12px;"></div>
      </section>


      <section class="card">
        <h2 style="margin:0 0 12px;font-size:16px;">カテゴリ別 上位事業（トップN）</h2>
        <div class="controls" style="margin-bottom:12px;">
          <div>
            <label for="categorySelect">カテゴリ</label>
            <select id="categorySelect"></select>
          </div>
          <div>
            <label for="yearSelectTop">年度</label>
            <select id="yearSelectTop"></select>
          </div>
          <div>
            <label for="topNCategory">上位表示数</label>
            <input id="topNCategory" type="number" min="3" max="50" value="5" />
          </div>
        </div>
        <table>
          <thead>
            <tr><th>事業名</th><th>金額（円）</th></tr>
          </thead>
          <tbody id="categoryTableBody"></tbody>
        </table>
      </section>

      <section class="card">
        <h2 style="margin:0 0 12px;font-size:16px;">AIで分類JSONを生成</h2>
        <div class="controls">
          <div>
            <label for="providerSelect">プロバイダ</label>
            <select id="providerSelect">
              <option value="openai">OpenAI</option>
              <option value="gemini">Google Gemini</option>
            </select>
          </div>
          <div>
            <label for="modelInput">モデル</label>
            <input id="modelInput" type="text" placeholder="OpenAI: gpt-4o-mini / Gemini: models/gemini-1.5-flash" />
          </div>
          <div>
            <label for="apiKeyInput">APIキー</label>
            <input id="apiKeyInput" type="password" placeholder="sk-... / AI Studio key" />
          </div>
          <div>
            <label for="rememberKey">キー保存</label>
            <select id="rememberKey">
              <option value="no">保存しない</option>
              <option value="yes">このブラウザに保存</option>
            </select>
          </div>
          <div>
            <label for="chunkSize">分割サイズ</label>
            <input id="chunkSize" type="number" min="50" max="500" value="200" />
          </div>
        </div>
        <div style="margin-top:12px;">
          <label for="categoryInput">カテゴリ一覧（1行=1カテゴリ、任意で説明）</label>
          <textarea id="categoryInput" rows="6" style="width:100%;padding:8px;border:1px solid #d1d5db;border-radius:8px;">未来に対する投資（教育、科学技術投資、子育て、人材育成、デジタル基盤、脱炭素）
現在の社会維持に関する支出（年金、医療、介護、行政、治安、防衛、インフラ維持など）
現在の経済対策に関連するコスト（給付金、補助金、物価高対策、景気対策など）
その他</textarea>
        </div>
        <div style="margin-top:12px;display:flex;gap:8px;flex-wrap:wrap;">
          <button id="generateBtn" style="padding:8px 12px;border:1px solid #d1d5db;border-radius:8px;background:#fff;cursor:pointer;">分類JSONを生成</button>
          <button id="applyBtn" style="padding:8px 12px;border:1px solid #d1d5db;border-radius:8px;background:#fff;cursor:pointer;" disabled>生成結果を適用</button>
          <button id="downloadBtn" style="padding:8px 12px;border:1px solid #d1d5db;border-radius:8px;background:#fff;cursor:pointer;" disabled>JSONをダウンロード</button>
        </div>
        <p id="genStatus" class="note" style="margin-top:8px;"></p>
        <p class="note">注意: GitHub Pagesのような静的サイトでAPIキーを使うとキーが露出します。自己責任で使用してください。</p>
      </section>
    </main>

    <script>
      const CSV_PATH = "データ/2-2_RS_2025_予算・執行_予算種別・歳出予算項目.csv";
      const fileInput = document.getElementById("fileInput");
      const ministrySelect = document.getElementById("ministrySelect");
      const accountSelect = document.getElementById("accountSelect");
      const aiMapInput = document.getElementById("aiMap");
      const legendEl = document.getElementById("legend");
      const stackedEl = document.getElementById("stacked");
      const categorySelect = document.getElementById("categorySelect");
      const yearSelectTop = document.getElementById("yearSelectTop");
      const topNCategory = document.getElementById("topNCategory");
      const categoryTableBody = document.getElementById("categoryTableBody");
      const presetSelect = document.getElementById("presetSelect");
      const providerSelect = document.getElementById("providerSelect");
      const modelInput = document.getElementById("modelInput");
      const apiKeyInput = document.getElementById("apiKeyInput");
      const rememberKey = document.getElementById("rememberKey");
      const chunkSizeInput = document.getElementById("chunkSize");
      const categoryInput = document.getElementById("categoryInput");
      const generateBtn = document.getElementById("generateBtn");
      const applyBtn = document.getElementById("applyBtn");
      const downloadBtn = document.getElementById("downloadBtn");
      const genStatus = document.getElementById("genStatus");
      const tooltip = document.createElement("div");
      tooltip.className = "tooltip";

      const numberFmt = new Intl.NumberFormat("ja-JP");
      const DEFAULT_CATEGORY_SET = [
        "行政サービス", "教育", "経済対策", "福祉", "防衛",
        "安全・治安", "インフラ・交通", "環境・エネルギー",
        "科学技術・研究", "文化・スポーツ", "農林水産", "産業・中小企業",
        "労働・雇用", "地方・地域振興", "外交・国際協力", "その他"
      ];
      const COLOR_PALETTE = [
        "#64748b", "#2563eb", "#f59e0b", "#10b981", "#ef4444",
        "#f97316", "#0ea5a4", "#22c55e", "#8b5cf6", "#ec4899",
        "#84cc16", "#0ea5e9", "#a3e635", "#6366f1", "#94a3b8"
      ];
      const CATEGORY_COLORS = { "その他": "#94a3b8" };
      let aiMap = null;
      let categoryList = [...DEFAULT_CATEGORY_SET];
      let visibleCategories = new Set(categoryList);
      let generatedMap = null;
      let classifyMode = "ai"; // "ai" | "ministry"
      const PRESET_JSONS = [
        { label: "選択なし", value: "" },
        { label: "省庁別（JSON不要）", value: "__ministry__" },
        { label: "初期分類", value: "ai_classification_map.json" },
        { label: "少子高齢化対応（高齢者/子ども・子育て/現役世代支援）", value: "ai_classification_map_demography.json" },
        { label: "人口×地域（地方創生/インフラ維持/防災・減災）", value: "ai_classification_map_region.json" },
        { label: "産業政策の色（中小企業/GX/技術・デジタル/通商・観光）", value: "ai_classification_map_industrial_policy.json" },
        { label: "安全保障の広がり（防衛/治安・サイバー/外交・ODA/経済安保）", value: "ai_classification_map_security.json" },
        { label: "政策の性格（給付/サービス/インフラ/行政）", value: "ai_classification_map_policy_character.json" },
        { label: "福祉細分（医療/子育て/介護/年金）", value: "ai_classification_map_welfare_split.json" },
        { label: "3軸分類（未来/社会維持/経済対策）", value: "ai_classification_map_3axis.json" }
      ];

      function parseCSV(text) {
        const rows = [];
        let i = 0, field = "", row = [], inQuotes = false;
        const pushField = () => { row.push(field); field = ""; };
        const pushRow = () => { rows.push(row); row = []; };
        while (i < text.length) {
          const c = text[i];
          if (inQuotes) {
            if (c === '"' && text[i + 1] === '"') { field += '"'; i += 2; continue; }
            if (c === '"') { inQuotes = false; i++; continue; }
            field += c; i++; continue;
          }
          if (c === '"') { inQuotes = true; i++; continue; }
          if (c === ",") { pushField(); i++; continue; }
          if (c === "\r") { i++; continue; }
          if (c === "\n") { pushField(); pushRow(); i++; continue; }
          field += c; i++;
        }
        if (field.length || row.length) { pushField(); pushRow(); }
        return rows;
      }

      function stripBOM(s) {
        return s && s.charCodeAt(0) === 0xfeff ? s.slice(1) : s;
      }

      function toNumber(val) {
        const n = Number(String(val || "").replace(/,/g, "").trim());
        return Number.isFinite(n) ? n : 0;
      }


      function classifyBusiness(name) {
        if (aiMap && aiMap[name]) return aiMap[name];
        const s = String(name || "");
        const rules = [
          { k: ["教育", "学校", "大学", "学生", "学習", "奨学"], c: "教育" },
          { k: ["福祉", "介護", "医療", "年金", "障害", "子ども", "育児", "保育"], c: "福祉" },
          { k: ["防衛", "自衛隊", "艦", "戦闘", "装備"], c: "防衛" },
          { k: ["警察", "治安", "消防", "防災", "災害"], c: "安全・治安" },
          { k: ["道路", "港", "空港", "鉄道", "交通", "上下水道", "都市", "住宅"], c: "インフラ・交通" },
          { k: ["環境", "脱炭素", "エネルギー", "再エネ", "省エネ"], c: "環境・エネルギー" },
          { k: ["研究", "技術", "科学", "イノベ", "デジタル"], c: "科学技術・研究" },
          { k: ["文化", "観光", "スポーツ", "芸術"], c: "文化・スポーツ" },
          { k: ["農業", "林業", "水産", "食料"], c: "農林水産" },
          { k: ["企業", "中小企業", "産業", "輸出", "商業"], c: "産業・中小企業" },
          { k: ["雇用", "労働", "賃金", "働き方"], c: "労働・雇用" },
          { k: ["地域", "地方", "振興", "過疎"], c: "地方・地域振興" },
          { k: ["外交", "国際", "援助", "ODA"], c: "外交・国際協力" },
          { k: ["税", "行政", "制度", "事務", "運営"], c: "行政サービス" }
        ];
        for (const r of rules) {
          if (r.k.some(k => s.includes(k))) return r.c;
        }
        return "その他";
      }

      function categoryForRow(row) {
        if (classifyMode === "ministry") return row["府省庁"] || "（不明）";
        // If an AI map is provided (preset/upload/generated), treat it as authoritative.
        // Unmapped names are ignored (not force-classified by keyword rules), because
        // business names can drift across years/exports.
        if (aiMap) return aiMap[row["事業名"]] ?? null;
        return classifyBusiness(row["事業名"]);
      }

      function aggregateByYearCategory(rows, ministry, account) {
        const years = Array.from(new Set(rows.map(r => r["予算年度"]).filter(Boolean))).sort();
        const result = new Map();
        for (const y of years) {
          result.set(y, new Map(categoryList.map(c => [c, 0])));
        }
        for (const r of rows) {
          if (ministry && r["府省庁"] !== ministry) continue;
          if (account && r["会計区分"] !== account) continue;
          const year = r["予算年度"];
          if (!year) continue;
          const cat = categoryForRow(r);
          if (!cat) continue;
          if (!visibleCategories.has(cat)) continue;
          const amount = toNumber(r["予算額（歳出予算項目ごと）"]);
          if (!amount) continue;
          const m = result.get(year);
          if (!m) continue;
          m.set(cat, (m.get(cat) || 0) + amount);
        }
        return { years, data: result };
      }

      function renderLegend() {
        legendEl.innerHTML = "";
        for (const c of categoryList) {
          const item = document.createElement("label");
          item.className = "legend-item";
          item.title = "チェックを外すとグラフから非表示になります。";

          const check = document.createElement("input");
          check.className = "legend-check";
          check.type = "checkbox";
          check.checked = visibleCategories.has(c);
          check.addEventListener("change", () => {
            if (check.checked) visibleCategories.add(c);
            else visibleCategories.delete(c);
            refresh();
          });

          const sw = document.createElement("span");
          sw.className = "legend-swatch";
          sw.style.background = CATEGORY_COLORS[c] || "#94a3b8";
          const tx = document.createElement("span");
          tx.textContent = c;
          item.appendChild(check);
          item.appendChild(sw);
          item.appendChild(tx);
          legendEl.appendChild(item);
        }
      }

      function renderStacked(rows) {
        stackedEl.innerHTML = "";
        const { years, data } = aggregateByYearCategory(rows, ministrySelect.value || "", accountSelect.value || "");
        if (!years.length) return;
        const totals = years.map(y => {
          const yearMap = data.get(y);
          return Array.from(yearMap.values()).reduce((a, b) => a + b, 0);
        });
        const maxTotal = Math.max(...totals, 1);

        const chart = document.createElement("div");
        chart.className = "stack-chart";

        const axis = document.createElement("div");
        axis.className = "y-axis";

        const plot = document.createElement("div");
        plot.className = "plot";
        plot.appendChild(tooltip);

        const barsGrid = document.createElement("div");
        barsGrid.className = "bars-grid";

        const tickCount = 5;
        for (let i = tickCount; i >= 0; i--) {
          const v = maxTotal * (i / tickCount);
          const label = document.createElement("div");
          label.textContent = formatShort(v);
          axis.appendChild(label);
        }
        for (let i = 1; i <= tickCount; i++) {
          const line = document.createElement("div");
          line.className = "gridline";
          line.style.top = `${(i / tickCount) * 100}%`;
          plot.appendChild(line);
        }

        years.forEach((y, idx) => {
          const yearMap = data.get(y);
          const total = totals[idx];
          const col = document.createElement("div");
          col.className = "stack-col";

          const holder = document.createElement("div");
          holder.className = "bar-holder";

          const bar = document.createElement("div");
          bar.className = "stack-bar";
          bar.style.height = `${(total / maxTotal) * 100}%`;

          for (const c of categoryList) {
            if (!visibleCategories.has(c)) continue;
            const v = yearMap.get(c) || 0;
            if (!v) continue;
            const seg = document.createElement("div");
            seg.className = "stack-seg";
            seg.style.height = `${(v / (total || 1)) * 100}%`;
            seg.style.background = CATEGORY_COLORS[c] || "#94a3b8";
            seg.addEventListener("mousemove", (e) => {
              tooltip.style.opacity = "1";
              tooltip.textContent = `${y} / ${c}: ${numberFmt.format(v)} 円`;
              const rect = chart.getBoundingClientRect();
              tooltip.style.left = `${e.clientX - rect.left}px`;
              tooltip.style.top = `${e.clientY - rect.top}px`;
            });
            seg.addEventListener("mouseleave", () => {
              tooltip.style.opacity = "0";
            });
            bar.appendChild(seg);
          }

          const label = document.createElement("div");
          label.className = "stack-label";
          label.textContent = y;

          holder.appendChild(bar);
          col.appendChild(holder);
          col.appendChild(label);
          barsGrid.appendChild(col);
        });

        plot.appendChild(barsGrid);
        chart.appendChild(axis);
        chart.appendChild(plot);
        stackedEl.appendChild(chart);
      }

      function assignColors(categories) {
        const known = new Set(Object.keys(CATEGORY_COLORS));
        let i = 0;
        for (const c of categories) {
          if (known.has(c)) continue;
          CATEGORY_COLORS[c] = COLOR_PALETTE[i % COLOR_PALETTE.length];
          i += 1;
        }
      }

      function updateCategories(rows) {
        const prevKnown = new Set(categoryList);
        const prevVisible = new Set(visibleCategories);

        const set = new Set();
        if (classifyMode === "ministry") {
          for (const r of rows) set.add(r["府省庁"] || "（不明）");
        } else if (aiMap) {
          Object.values(aiMap).forEach(v => set.add(v));
        } else {
          DEFAULT_CATEGORY_SET.forEach(v => set.add(v));
        }
        // Note: when aiMap is present we don't infer categories from the CSV content,
        // because unmapped business names are intentionally ignored.
        categoryList = Array.from(set);
        if (classifyMode !== "ministry" && !categoryList.includes("その他")) categoryList.push("その他");
        assignColors(categoryList);

        // Preserve prior user selections; new categories default to visible.
        const next = new Set();
        for (const c of categoryList) {
          if (!prevKnown.has(c)) {
            next.add(c);
            continue;
          }
          if (prevVisible.has(c)) next.add(c);
        }
        visibleCategories = next;
      }

      function syncCategorySelect() {
        categorySelect.innerHTML =
          `<option value="__all__">（全て）</option>` +
          categoryList.map(c => `<option value="${c}">${c}</option>`).join("");
      }

      function formatShort(n) {
        if (n >= 1e12) return `${(n / 1e12).toFixed(1)}兆`;
        if (n >= 1e8) return `${(n / 1e8).toFixed(1)}億`;
        if (n >= 1e4) return `${(n / 1e4).toFixed(1)}万`;
        return numberFmt.format(Math.round(n));
      }

      function getCategoryListFromInput() {
        return categoryInput.value
          .split("\n")
          .map(s => s.trim())
          .filter(Boolean)
          .map(s => s.split("（")[0].split("(")[0].trim());
      }

      function buildPrompt(names) {
        const categories = getCategoryListFromInput();
        return [
          "以下の事業名を、指定カテゴリのいずれかに分類してください。",
          "出力はJSONオブジェクトのみで、キーが事業名、値がカテゴリ名です。",
          "カテゴリ一覧:",
          categories.map(c => `- ${c}`).join("\n"),
          "事業名一覧:",
          names.map(n => `- ${n}`).join("\n")
        ].join("\n");
      }

      function parseJsonLoose(text) {
        const start = text.indexOf("{");
        const end = text.lastIndexOf("}");
        if (start === -1 || end === -1) throw new Error("JSON not found");
        return JSON.parse(text.slice(start, end + 1));
      }

      async function callOpenAI(apiKey, model, prompt) {
        const res = await fetch("https://api.openai.com/v1/chat/completions", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${apiKey}`
          },
          body: JSON.stringify({
            model,
            messages: [
              { role: "system", content: "You are a classifier. Return only JSON." },
              { role: "user", content: prompt }
            ],
            temperature: 0
          })
        });
        if (!res.ok) throw new Error(`OpenAI error: ${res.status}`);
        const data = await res.json();
        const text = data.choices?.[0]?.message?.content || "";
        return parseJsonLoose(text);
      }

      async function callGemini(apiKey, model, prompt) {
        const res = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "x-goog-api-key": apiKey
          },
          body: JSON.stringify({
            contents: [
              { role: "user", parts: [{ text: prompt }] }
            ]
          })
        });
        if (!res.ok) throw new Error(`Gemini error: ${res.status}`);
        const data = await res.json();
        const text = data.candidates?.[0]?.content?.parts?.[0]?.text || "";
        return parseJsonLoose(text);
      }

      async function generateClassification() {
        if (!window.__rows) {
          genStatus.textContent = "先にCSVを読み込んでください。";
          return;
        }
        const apiKey = apiKeyInput.value.trim();
        if (!apiKey) {
          genStatus.textContent = "APIキーを入力してください。";
          return;
        }
        const provider = providerSelect.value;
        const model = modelInput.value.trim();
        if (!model) {
          genStatus.textContent = "モデル名を入力してください。";
          return;
        }
        const size = Math.max(50, Math.min(500, Number(chunkSizeInput.value) || 200));
        const names = Array.from(new Set(window.__rows.map(r => r["事業名"]).filter(Boolean)));
        const chunks = [];
        for (let i = 0; i < names.length; i += size) chunks.push(names.slice(i, i + size));

        generatedMap = {};
        applyBtn.disabled = true;
        downloadBtn.disabled = true;
        genStatus.textContent = `分類生成中: 0 / ${chunks.length}`;

        for (let i = 0; i < chunks.length; i++) {
          const prompt = buildPrompt(chunks[i]);
          const part = provider === "gemini"
            ? await callGemini(apiKey, model, prompt)
            : await callOpenAI(apiKey, model, prompt);
          Object.assign(generatedMap, part);
          genStatus.textContent = `分類生成中: ${i + 1} / ${chunks.length}`;
        }

        genStatus.textContent = "分類生成が完了しました。";
        applyBtn.disabled = false;
        downloadBtn.disabled = false;
      }

      function renderCategoryTopN(rows) {
        if (!rows) return;
        const targetCat = categorySelect.value || "その他";
        const topN = Math.max(3, Math.min(50, Number(topNCategory.value) || 5));
        const map = new Map();
        const ministry = ministrySelect.value || "";
        const account = accountSelect.value || "";
        const year = yearSelectTop.value || "";
        for (const r of rows) {
          if (ministry && r["府省庁"] !== ministry) continue;
          if (account && r["会計区分"] !== account) continue;
          if (year && year !== "__all__" && r["予算年度"] !== year) continue;
          const name = r["事業名"] || "（不明）";
          const cat = categoryForRow(r);
          if (!cat) continue;
          if (targetCat !== "__all__" && cat !== targetCat) continue;
          const amount = toNumber(r["予算額（歳出予算項目ごと）"]);
          if (!amount) continue;
          map.set(name, (map.get(name) || 0) + amount);
        }
        const entries = Array.from(map.entries()).sort((a, b) => b[1] - a[1]).slice(0, topN);
        categoryTableBody.innerHTML = "";
        if (!entries.length) {
          const tr = document.createElement("tr");
          const td = document.createElement("td");
          td.colSpan = 2;
          td.textContent = "該当するデータがありません。";
          tr.appendChild(td);
          categoryTableBody.appendChild(tr);
          return;
        }
        for (const [name, value] of entries) {
          const tr = document.createElement("tr");
          const td1 = document.createElement("td");
          td1.textContent = name;
          const td2 = document.createElement("td");
          td2.textContent = numberFmt.format(value);
          tr.appendChild(td1);
          tr.appendChild(td2);
          categoryTableBody.appendChild(tr);
        }
      }

      function refresh() {
        const ministry = ministrySelect.value || "";
        const account = accountSelect.value || "";
        renderStacked(window.__rows);
        renderCategoryTopN(window.__rows);
      }

      function initControls(rows) {
        const ministries = Array.from(new Set(rows.map(r => r["府省庁"]).filter(Boolean))).sort();
        ministrySelect.innerHTML = `<option value="">（全府省庁）</option>` + ministries.map(m => `<option value="${m}">${m}</option>`).join("");

        ministrySelect.addEventListener("change", refresh);
        accountSelect.addEventListener("change", refresh);
        categorySelect.addEventListener("change", refresh);
        yearSelectTop.addEventListener("change", refresh);
        topNCategory.addEventListener("input", refresh);
      }

      function loadText(text) {
        const rows = parseCSV(text);
        const header = rows.shift().map(stripBOM);
        const objects = rows.map(cols => {
          const obj = {};
          for (let i = 0; i < header.length; i++) obj[header[i]] = cols[i];
          return obj;
        });
        window.__rows = objects;
        updateCategories(objects);
        renderLegend();
        syncCategorySelect();
        const years = Array.from(new Set(objects.map(r => r["予算年度"]).filter(Boolean))).sort();
        const latest = years[years.length - 1] || "";
        yearSelectTop.innerHTML = `<option value="${latest}">${latest}</option><option value="__all__">（全て）</option>` + years.filter(y => y !== latest).map(y => `<option value="${y}">${y}</option>`).join("");
        initControls(objects);
        refresh();
      }

      fileInput.addEventListener("change", (e) => {
        const file = e.target.files && e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = () => loadText(reader.result);
        reader.onerror = () => {
          genStatus.textContent = "CSVの読み込みに失敗しました。";
        };
        reader.readAsText(file, "utf-8");
      });

      aiMapInput.addEventListener("change", (e) => {
        const file = e.target.files && e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = () => {
          try {
            classifyMode = "ai";
            aiMap = JSON.parse(reader.result);
            if (window.__rows) {
              updateCategories(window.__rows);
              visibleCategories = new Set(categoryList);
              renderLegend();
              syncCategorySelect();
              const years = Array.from(new Set(window.__rows.map(r => r["予算年度"]).filter(Boolean))).sort();
              const latest = years[years.length - 1] || "";
              yearSelectTop.innerHTML = `<option value="${latest}">${latest}</option><option value="__all__">（全て）</option>` + years.filter(y => y !== latest).map(y => `<option value="${y}">${y}</option>`).join("");
              refresh();
            }
          } catch (_) {
            genStatus.textContent = "AI分類JSONの読み込みに失敗しました。";
          }
        };
        reader.readAsText(file, "utf-8");
      });

      presetSelect.innerHTML = PRESET_JSONS.map(p => `<option value="${p.value}">${p.label}</option>`).join("");
      presetSelect.addEventListener("change", async () => {
        if (!presetSelect.value) return;
        if (presetSelect.value === "__ministry__") {
          classifyMode = "ministry";
          aiMap = null;
          if (window.__rows) {
            updateCategories(window.__rows);
            visibleCategories = new Set(categoryList);
            renderLegend();
            syncCategorySelect();
            refresh();
            genStatus.textContent = "省庁別プリセットを適用しました（分類JSONは使用しません）。";
          }
          return;
        }
        try {
          classifyMode = "ai";
          const res = await fetch(presetSelect.value);
          const text = await res.text();
          aiMap = JSON.parse(text);
          if (window.__rows) {
            updateCategories(window.__rows);
            visibleCategories = new Set(categoryList);
            renderLegend();
            syncCategorySelect();
            refresh();
          }
        } catch (e) {
          genStatus.textContent = "プリセットJSONの読み込みに失敗しました。";
        }
      });

      rememberKey.addEventListener("change", () => {
        if (rememberKey.value === "yes") {
          localStorage.setItem("ai_api_key", apiKeyInput.value);
        } else {
          localStorage.removeItem("ai_api_key");
        }
      });

      apiKeyInput.addEventListener("input", () => {
        if (rememberKey.value === "yes") {
          localStorage.setItem("ai_api_key", apiKeyInput.value);
        }
      });

      const savedKey = localStorage.getItem("ai_api_key");
      if (savedKey) {
        apiKeyInput.value = savedKey;
        rememberKey.value = "yes";
      }

      generateBtn.addEventListener("click", () => {
        generateClassification().catch(err => {
          genStatus.textContent = `生成に失敗しました: ${err.message}`;
        });
      });

      applyBtn.addEventListener("click", () => {
        if (!generatedMap) return;
        classifyMode = "ai";
        aiMap = generatedMap;
        if (window.__rows) {
          updateCategories(window.__rows);
          visibleCategories = new Set(categoryList);
          renderLegend();
          syncCategorySelect();
          refresh();
        }
      });

      downloadBtn.addEventListener("click", () => {
        if (!generatedMap) return;
        const blob = new Blob([JSON.stringify(generatedMap, null, 2)], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "ai_classification_map_custom.json";
        a.click();
        URL.revokeObjectURL(url);
      });

      fetch(CSV_PATH)
        .then(r => r.text())
        .then(loadText)
        .catch(err => {
          genStatus.textContent = "CSVの読み込みに失敗しました。ファイル選択で読み込んでください。";
          console.error(err);
        });
    </script>
  </body>
</html>
